using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;

namespace locgen.Impl
{
	/// <summary>
	/// A C++ code generator.
	/// </summary>
	internal sealed class CppCodeGenerator : LocCodeGenerator
	{
		#region data
		#endregion

		#region interface

		public CppCodeGenerator(LocCodeGeneratorSettings settings)
			: base(CodeGenType.Cpp, settings)
		{
		}

		#endregion

		#region LocCodeGenerator

		protected override void GenerateInternal(LocTree data, string path, CancellationToken cancellationToken)
		{
			using (var file = File.CreateText(path))
			{
				WriteFileHeader(file, cancellationToken);
				WriteData(file, data, cancellationToken);
			}
		}

		protected override string GetTargetFileExtension()
		{
			return ".generated.h";
		}

		#endregion

		#region implementation

		private void WriteFileHeader(StreamWriter file, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();

			file.WriteLine("// <auto-generated>");
			file.WriteLine("// This code was generated with locgen. Do not edit.");
			file.WriteLine("// " + DateTime.Now.ToString(@"yyyy\/MM\/dd HH:mm"));
			file.WriteLine("// ");
			file.WriteLine("// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
			file.WriteLine("// </auto-generated>");
		}

		private void WriteData(StreamWriter file, LocTree data, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();

			file.WriteLine("#pragma once");
			file.WriteLine();

			if (string.IsNullOrEmpty(Settings.TargetNamespace))
			{
				WriteLocTree(file, data, cancellationToken, 0);
			}
			else
			{
				file.WriteLine("namespace " + Settings.TargetNamespace);
				file.WriteLine('{');
				WriteLocTree(file, data, cancellationToken, 1);
				file.WriteLine('}');
			}
		}

		private void WriteLocTree(StreamWriter file, LocTree tree, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			WriteLocNotes(file, tree, identLevel);

			if (Settings.StaticAccess)
			{
				WriteIdent(file, identLevel, "static class " + tree.Name);
				WriteIdent(file, identLevel, "{");
				WriteIdent(file, identLevel, "public:");
			}
			else
			{
				WriteIdent(file, identLevel, "class " + tree.Name);
				WriteIdent(file, identLevel, "{");
				WriteIdent(file, identLevel, "private:");

				WriteIdent(file, identLevel + 1, $"const {Settings.ResourceManagerClass} & _resourceManager;");
				file.WriteLine();

				WriteIdent(file, identLevel, "public:");
				WriteIdent(file, identLevel + 1, GetGroupConstructor(tree));
				file.WriteLine();
			}

			WriteLocGroupContent(file, tree, cancellationToken, identLevel + 1);
			WriteIdent(file, identLevel, "};");

			if (Settings.GenerateLocKeys)
			{
				file.WriteLine();

				WriteLocNotes(file, tree, identLevel);
				WriteIdent(file, identLevel, "static class " + tree.Name + "Keys");
				WriteIdent(file, identLevel, "{");
				WriteLocGroupContentKeys(file, tree, cancellationToken, identLevel + 1);
				WriteIdent(file, identLevel, "};");
			}
		}

		private void WriteLocGroupContent(StreamWriter file, LocTreeGroup group, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			foreach (var item in group.Groups)
			{
				WriteLocGroup(file, item, cancellationToken, identLevel);
				file.WriteLine();
			}

			foreach (var item in group.Units)
			{
				WriteLocUnit(file, item, cancellationToken, identLevel);
				file.WriteLine();
			}
		}

		private void WriteLocGroupContentKeys(StreamWriter file, LocTreeGroup group, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			foreach (var item in group.Groups)
			{
				WriteLocGroupKeys(file, item, cancellationToken, identLevel);
				file.WriteLine();
			}

			foreach (var item in group.Units)
			{
				WriteLocUnitKeys(file, item, cancellationToken, identLevel);
				file.WriteLine();
			}
		}

		private void WriteLocGroup(StreamWriter file, LocTreeGroup group, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			if (Settings.StaticAccess)
			{
				WriteLocNotes(file, group, identLevel);
				WriteIdent(file, identLevel, $"static class {group.Name}");
				WriteIdent(file, identLevel, "{");
				WriteIdent(file, identLevel, "public:");

				WriteLocGroupContent(file, group, cancellationToken, identLevel + 1);

				WriteIdent(file, identLevel, "};");
			}
			else
			{
				var groupClassName = GetGroupClassName(group.Name);

				WriteIdent(file, identLevel, $"class {groupClassName}");
				WriteIdent(file, identLevel, "{");
				WriteIdent(file, identLevel, "private:");

				WriteIdent(file, identLevel + 1, $"const {Settings.ResourceManagerClass} & _resourceManager;");
				file.WriteLine();

				WriteIdent(file, identLevel, "public:");
				WriteIdent(file, identLevel + 1, GetGroupConstructor(group));
				file.WriteLine();

				WriteLocGroupContent(file, group, cancellationToken, identLevel + 1);
				WriteIdent(file, identLevel, "};");
				file.WriteLine();

				WriteLocNotes(file, group, identLevel);
				WriteIdent(file, identLevel, $"{groupClassName} {group.Name};");
			}
		}

		private void WriteLocGroupKeys(StreamWriter file, LocTreeGroup group, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			WriteLocNotes(file, group, identLevel);
			WriteIdent(file, identLevel, $"static class {group.Name}");
			WriteIdent(file, identLevel, "{");
			WriteIdent(file, identLevel, "public:");

			WriteLocGroupContentKeys(file, group, cancellationToken, identLevel + 1);
			WriteIdent(file, identLevel, "};");
		}

		private void WriteLocUnit(StreamWriter file, LocTreeUnit unit, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			WriteLocNotes(file, unit, identLevel);

			if (Settings.StaticAccess)
			{
				WriteIdent(file, identLevel, $"static const wchar_t * Get{unit.Name}Text() {{ return {Settings.ResourceManagerClass}::{Settings.ResourceManagerGetStringMethod}(\"{unit.Id}\"); }}");
			}
			else
			{
				WriteIdent(file, identLevel, $"const wchar_t * Get{unit.Name}Text() {{ return _resourceManager.{Settings.ResourceManagerGetStringMethod}(\"{unit.Id}\"); }}");
			}
		}

		private void WriteLocUnitKeys(StreamWriter file, LocTreeUnit unit, CancellationToken cancellationToken, int identLevel)
		{
			cancellationToken.ThrowIfCancellationRequested();

			WriteLocNotes(file, unit, identLevel);
			WriteIdent(file, identLevel, $"const const char * {unit.Name} = \"{unit.Id}\";");
		}

		private void WriteLocNotes(StreamWriter file, LocTreeItem item, int identLevel)
		{
			var unit = item as LocTreeUnit;
			var hasNotes = !string.IsNullOrEmpty(item.Notes);

			if (item is LocTreeText textUnit)
			{
				if (!string.IsNullOrEmpty(textUnit.SrcValue))
				{
					var first = true;

					foreach (var line in textUnit.SrcValue.Split(new char[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries))
					{
						if (first)
						{
							first = false;
							WriteIdent(file, identLevel, "/// " + item.Path + ": " + line);
						}
						else
						{
							WriteIdent(file, identLevel, "/// " + line);
						}
					}
				}
				else
				{
					WriteIdent(file, identLevel, "/// " + item.Path);
				}
			}
			else
			{
				WriteIdent(file, identLevel, "/// " + item.Path);
			}

			WriteIdent(file, identLevel, "// ItemId: " + item.Id);
			WriteIdent(file, identLevel, "// OriginalName: " + item.OriginalName);

			if (hasNotes)
			{
				var first = true;

				foreach (var line in item.Notes.Split(new char[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries))
				{
					if (first)
					{
						first = false;
						WriteIdent(file, identLevel, "// Notes: " + line);
					}
					else
					{
						WriteIdent(file, identLevel, "//        " + line);
					}
				}
			}
		}

		private string GetGroupConstructor(LocTreeGroup group)
		{
			var text = new StringBuilder(256);
			var name = group is LocTree ? group.Name : GetGroupClassName(group.Name);

			text.AppendFormat("{0}(const {1} & resourceManager) : _resourceManager(resourceManager)", name, Settings.ResourceManagerClass);

			foreach (var g in group.Groups)
			{
				text.Append($", {g.Name}(resourceManager)");
			}

			text.Append(" {}");

			return text.ToString();
		}

		private static string GetGroupClassName(string groupName)
		{
			return '_' + groupName + "_Proxy";
		}

		#endregion
	}
}
